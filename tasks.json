{
  "project": "securepay",
  "author": "Doğuhan İlter",
  "created": "2026-02-15",
  "context_files": [
    ".ctx/architecture.md",
    ".ctx/conventions.md",
    ".ctx/decisions.md"
  ],
  "tasks": [
    {
      "id": 1,
      "phase": "Initializing API Gateway",
      "title": "SPIFFE — Install SVID and Generate mTLS Credentials",
      "description": "Create api-gateway/spiffe.go. Use SPIFFE Go SDK to fetch X.509 SVID from SPIRE Agent. SPIFFE ID: spiffe://securepay.dev/api-gateway. Write a function returning mTLS client credentials for Payment Service: verify SPIFFE ID spiffe://securepay.dev/payment-service. Write a function returning mTLS client credentials for Account Service: verify SPIFFE ID spiffe://securepay.dev/account-service. Socket path: /tmp/spire-agent/public/api.sock.",
      "priority": "high",
      "status": "completed",
      "output": "api-gateway/spiffe.go",
      "done_when": [
        "spiffe.go file created",
        "SVID fetched using workloadapi.NewX509Source",
        "mTLS credential function exists for Payment Service",
        "mTLS credential function exists for Account Service",
        "Both functions verify SPIFFE IDs"
      ]
    },
    {
      "id": 2,
      "phase": "Initializing API Gateway",
      "title": "gRPC Client — Payment Service Connection",
      "description": "Create api-gateway/grpc_clients.go. Use the Payment Service mTLS credential function from spiffe.go. Connect to payment-service:50051 using grpc.Dial. Write a function returning PaymentServiceClient. Do not use static credentials or insecure connections.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        1
      ],
      "output": "api-gateway/grpc_clients.go",
      "done_when": [
        "grpc_clients.go file created",
        "grpc.Dial exists for Payment Service",
        "mTLS credentials come from spiffe.go",
        "No insecure connections"
      ]
    },
    {
      "id": 3,
      "phase": "Initializing API Gateway",
      "title": "gRPC Client — Account Service Connection",
      "description": "Add Account Service connection to api-gateway/grpc_clients.go. Use the Account Service mTLS credential function from spiffe.go. Connect to account-service:50051 using grpc.Dial. Write a function returning AccountServiceClient.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        1
      ],
      "output": "api-gateway/grpc_clients.go",
      "done_when": [
        "grpc.Dial exists for Account Service",
        "mTLS credentials come from spiffe.go",
        "Function returning AccountServiceClient exists"
      ]
    },
    {
      "id": 3.1,
      "phase": "Initializing API Gateway",
      "title": "gRPC Proto Definitions",
      "description": "Create proto/ folder. Write two proto files. (1) proto/payment.proto: Define InitiatePayment and GetPayment RPCs for PaymentService. InitiatePaymentRequest: payment_id string, from_account string, to_account string, amount double, currency string, idempotency_key string. InitiatePaymentResponse: payment_id string, status enum (PENDING, COMPLETED, FAILED), message string. (2) proto/account.proto: Define CheckBalance RPC for AccountService. CheckBalanceRequest: account_id string. CheckBalanceResponse: account_id string, balance double, currency string. Ensure go_package is defined in both files.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        1,
        2,
        3
      ],
      "output": "proto/payment.proto, proto/account.proto",
      "done_when": [
        "proto/payment.proto created",
        "proto/account.proto created",
        "InitiatePayment RPC defined",
        "GetPayment RPC defined",
        "CheckBalance RPC defined",
        "go_package defined in both files",
        "Compilable with protoc"
      ]
    },
    {
      "id": 3.2,
      "phase": "Initializing API Gateway",
      "title": "gRPC Proto Compilation",
      "description": "Install and test `protoc` and `protoc-gen-go` plugins in the development environment.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        1,
        2,
        3,
        4
      ],
      "output": "compiled proto files",
      "done_when": [
        "Compiled proto files created."
      ]
    },
    {
      "id": 3.3,
      "phase": "Initializing API Gateway",
      "title": "gRPC Proto Compilation and main.go Creation",
      "description": "Create a simple main.go. Run go build for grpc_clients.go again. Ensure Proto works. Main.go should only open port 8080. This port can be hard-coded.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        1,
        2,
        3
      ],
      "output": "api-gateway/main.go",
      "done_when": [
        "main.go created",
        "Port set to 8080",
        "Proto works"
      ]
    },
    {
      "id": 4,
      "phase": "Initializing API Gateway",
      "title": "Middleware — JWT Verification",
      "description": "Create api-gateway/middleware/jwt.go. Extract Bearer token from Authorization header. Verify the token. Return 401 for invalid tokens. Proceed to next handler for valid tokens. Apply only to /api/v1/ prefixed endpoints, excluding /health.",
      "priority": "high",
      "status": "completed",
      "output": "api-gateway/middleware/jwt.go",
      "done_when": [
        "jwt.go file created",
        "Bearer token parsing implemented",
        "Invalid token returns 401",
        "/health endpoint excluded from JWT"
      ]
    },
    {
      "id": 4.1,
      "phase": "Initializing API Gateway",
      "title": "Middleware — JWT Verification - Curl Requests",
      "description": "You created api-gateway/middleware/jwt.go. Ensure /health endpoint does not require JWT token. Ensure others require JWT. Ensure others return success when provided with a hard-coded JWT.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        4
      ],
      "output": "",
      "done_when": [
        "All Curl results returned success."
      ]
    },
    {
      "id": 5,
      "phase": "Initializing API Gateway",
      "title": "Middleware — Rate Limiting",
      "description": "Create api-gateway/middleware/ratelimit.go. Max 100 requests per minute per IP. Return 429 Too Many Requests when limit is exceeded. In-memory token bucket is sufficient, Redis not required. Keep it simple.",
      "priority": "high",
      "status": "completed",
      "output": "api-gateway/middleware/ratelimit.go",
      "done_when": [
        "ratelimit.go file created",
        "IP-based limit implemented",
        "Max 100 requests per minute",
        "Returns 429 when limit exceeded"
      ]
    },
    {
      "id": 5.1,
      "phase": "GitHub Break",
      "title": "Push Previous IDs To GitHub",
      "description": "I want you to commit the files created in previous IDs using conventional commits in an ID-based manner: git add --> git commit -m 'conventional_commits(scope): ID's description with formal way' --> git push origin master. Each ID should be a separate commit. Commits must be in English.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        1,
        2,
        3,
        4,
        5
      ],
      "output": "git commits created",
      "done_when": [
        "IDs 1, 2, 3, 4, 5 pushed to GitHub"
      ]
    },
    {
      "id": 6,
      "phase": "Initializing API Gateway",
      "title": "Router — Route Definitions",
      "description": "Create api-gateway/router.go. This file should ONLY contain route definitions, no business logic. Endpoints: POST /api/v1/payments, GET /api/v1/payments/{id}, GET /api/v1/accounts/{id}/balance, GET /health. Apply JWT and rate limit middleware chain to /api/v1/ endpoints. Each endpoint receives HTTP request, forwards to respective downstream service via gRPC client in grpc_clients.go, and returns gRPC response as HTTP. Do not use httputil.ReverseProxy. Do not leave handler as stub, make real gRPC calls.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        2,
        3,
        4,
        5
      ],
      "output": "api-gateway/router.go",
      "done_when": [
        "router.go file created",
        "POST /api/v1/payments endpoint exists, calls Payment Service gRPC",
        "GET /api/v1/payments/{id} endpoint exists, calls Payment Service gRPC",
        "GET /api/v1/accounts/{id}/balance endpoint exists, calls Account Service gRPC",
        "GET /health endpoint exists, no JWT middleware",
        "httputil.ReverseProxy not used",
        "JWT and rate limit middleware chain applied"
      ]
    },
    {
      "id": 7,
      "phase": "Initializing API Gateway",
      "title": "main.go — Start API Gateway",
      "description": "Create api-gateway/main.go. Initialize SPIFFE X509Source. Establish gRPC client connections. Start HTTP server on port 8080. Register router. Implement graceful shutdown: close open connections on SIGTERM or SIGINT.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        6
      ],
      "output": "api-gateway/main.go",
      "done_when": [
        "main.go file created",
        "HTTP server starts on port 8080",
        "SPIFFE X509Source initialized",
        "Graceful shutdown implemented"
      ]
    },
    {
      "id": 8,
      "phase": "Initializing Dockerfile",
      "title": "Create Dockerfile for api-gateway",
      "description": "Create a dockerfile for api-gateway. Pay attention to system requirements. Build the created Dockerfile. Ensure the built Docker container runs on port 8080.",
      "priority": "high",
      "status": "completed",
      "output": "api-gateway/apigateway.dockerfile",
      "done_when": [
        "apigateway dockerfile created",
        "apigateway dockerfile built",
        "apigateway container run",
        "apigateway running healthily on port 8080"
      ]
    },
    {
      "id": 9,
      "phase": "GitHub Break",
      "status": "completed",
      "output": "git commits pushed",
      "done_when": [
        "ID 6, 7, 8 committed and pushed"
      ]
    },
    {
      "id": 10,
      "phase": "Create MIT License and create 'feat: mit license created' commit and push.",
      "status": "completed",
      "output": "git commits pushed",
      "done_when": [
        "MIT License created."
      ]
    },
    {
      "id": 11,
      "phase": "Initializing Dockerfile",
      "title": "Rebuild api-gateway for WSL",
      "description": "We already built api-gateway, but since I am moving to WSL, it needs to be built again within WSL.",
      "priority": "high",
      "status": "completed",
      "output": "api-gateway/apigateway.dockerfile",
      "done_when": [
        "apigateway dockerfile created",
        "apigateway dockerfile built",
        "apigateway container run",
        "apigateway running healthily on port 8080"
      ]
    },
    {
      "id": 12,
      "phase": "Deploy to Kubernetes",
      "title": "Start minikube from deploy-k8s.sh",
      "description": "I want you to move the Install Minikube structure found in example/deploy-8s.sh to a new file. Name it /hack/1-minikube-start.sh. Ensure Minikube is running on WSL.",
      "priority": "high",
      "status": "completed",
      "output": "hack/1-minikube-start.sh",
      "done_when": [
        "hack/1-minikube-start.sh file created",
        "Minikube is running"
      ]
    },
    {
      "id": 13,
      "phase": "Deploy to Kubernetes",
      "title": "Installing Helm Step",
      "description": "I want you to move the Step 2: Installing Helm structure found in example/deploy-8s.sh to a new file. Name it /hack/2-installing-helm.sh. Ensure Helm is running on WSL.",
      "priority": "high",
      "status": "completed",
      "output": "/hack/2-installing-helm.sh",
      "done_when": [
        "/hack/2-installing-helm.sh file created",
        "Helm is running"
      ]
    },
    {
      "id": 14,
      "phase": "Deploy to Kubernetes",
      "title": "Starting Minikube Step",
      "description": "I want you to move the Step 3: Starting minikube structure found in example/deploy-8s.sh to a new file. Name it /hack/2-starting-minikube.sh. Ensure Helm is running on WSL.",
      "priority": "high",
      "status": "completed",
      "output": "/hack/2-starting-minikube.sh",
      "done_when": [
        "/hack/2-starting-minikube.sh file created",
        "minikube is running"
      ]
    },
    {
      "id": 15,
      "phase": "Deploy to Kubernetes",
      "title": "Installing SPIRE",
      "description": "I want you to move the Step 4: Installing SPIRE structure found in example/deploy-8s.sh to a new file. Name it /hack/4-installing-spire.sh. Ensure Helm is running on WSL.",
      "priority": "high",
      "status": "completed",
      "output": "/hack/4-installing-spire.sh ",
      "done_when": [
        "/hack/4-installing-spire.sh file created",
        "Spire is running"
      ]
    },
    {
      "id": 16,
      "phase": "Deploy to Kubernetes",
      "title": "REGISTER SPIRE",
      "description": "I want you to move the Step 4.5: Register each service with SPIRE structure found in example/deploy-8s.sh to a new file. Name it /hack/5-register-spire.sh. Ensure Helm is running on WSL. Pay attention to the rules in /.ctx. This Register is only for api-gateway, do not do it for others.",
      "priority": "high",
      "status": "completed",
      "output": "/hack/5-register-spire.sh ",
      "done_when": [
        "Register created for api-gateway"
      ]
    },
    {
      "id": 17,
      "phase": "Deploy to Kubernetes",
      "title": "Create Deployment, Service, Serviceaccount, Configmap, Memory-related YAMLs for Api-Gateway",
      "description": "Create the YAML files mentioned in the title for api-gateway inside the /k8s folder. Also perform the necessary setup for SPIFFE/SPIRE there for api-gateway. Explicitly state in the YAML which socket the certificate will be connected from, etc.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        16
      ],
      "output": "apigateway-deployment.yaml, apigateway-service.yaml, apigateway-serviceaccount.yaml, apigateway-configmap.yaml, apigateway-memory.yaml",
      "done_when": [
        "Deployment, Service, Serviceaccount, Configmap, Memory-related Yamls created for Api-gateway."
      ]
    },
    {
      "id": 17.5,
      "phase": "GITHUB BREAK",
      "description": "Find github.md and apply it."
    },
    {
      "id": 18,
      "phase": "Deploy to Kubernetes",
      "title": "Apply Yamls for apigateway",
      "description": "Apply the YAMLs found for api-gateway inside the /k8s folder and ensure it works. Enter inside and ensure it receives SPIFFE certificate. System must work.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        16,
        17
      ],
      "output": "",
      "done_when": [
        "api-gateway service received SPIFFE certificate inside Kubernetes.",
        "api-gateway returned response to /health endpoint."
      ]
    },
    {
      "id": 19,
      "phase": "GITHUB BREAK",
      "description": "Find github.md and apply it."
    },
    {
      "id": 20,
      "phase": "PostgreSQL - HELM",
      "title": "Create PostgreSQL Instance With HELM",
      "description": [
        "Since we will use PostgreSQL integrated with Kubernetes on WSL, download it via Helm.",
        "For example: helm repo add bitnami https://charts.bitnami.com/bitnami AND helm repo update AND helm install my-postgres bitnami/postgresql --set auth.username=myuser --set auth.password=mypass --set auth.database=mydb",
        "You can use this to connect, try it. You use this address from services inside the cluster: my-postgres-postgresql.default.svc.cluster.local:5432"
      ],
      "priority": "high",
      "status": "completed",
      "output": "postgresql helm instance",
      "done_when": [
        "PostgreSQL installed via Helm",
        "Request sent to PostgreSQL connection."
      ]
    },
    {
      "id": 21,
      "phase": "PostgreSQL - MIGRATION",
      "title": "Migrate services.md suggestions to PostgreSQL",
      "description": [
        "PostgreSQL created via HELM. Write script to migrate into it.",
        "Script name migrate/init.sql",
        "Migrate the script."
      ],
      "depends_on": [
        20
      ],
      "priority": "high",
      "status": "completed",
      "output": "init.sql",
      "done_when": [
        "Tables created.",
        "Sample users added."
      ]
    },
    {
      "id": 21,
      "phase": "Payment Service",
      "title": "Payment Service Init",
      "description": [
        "I want you to go init the Payment Service and start gRPC inside, with port 8081."
      ],
      "priority": "high",
      "status": "completed",
      "output": "payment-service/main.go",
      "done_when": [
        "Port 8081",
        "gRPC server started",
        "payment-service started and tested"
      ]
    },
    {
      "id": 21,
      "phase": "Payment Service",
      "title": "Payment Service - Handler",
      "description": [
        "I want you to create a handler named handler.go, implement InitiatePayment, GetPayment. Make sure that you use correct gRPC server.",
        "When GetPayment arrives: Fetch from payments.transactions table with payment_id, if not found --> return gRPC NotFound Error, if not found: return all fields"
      ],
      "priority": "high",
      "status": "completed",
      "output": "payment-service/handler.go",
      "done_when": [
        "InitiatePayment handler added",
        "GetPayment handler added",
        "Test proto file"
      ]
    },
    {
      "id": 22,
      "phase": "Payment Service",
      "title": "Payment Service - Repository",
      "description": [
        "I want you to create a repository named repository.go, this file implements PostgreSQL operations. Make it simple as much as possible. No need for complexity for now.",
        "Save to payments.transactions table as PENDING",
        "Version: 1 (for optimistic locking)"
      ],
      "priority": "high",
      "status": "completed",
      "output": "payment-service/repository.go",
      "done_when": [
        "The repository file gives everything that the handler needs."
      ]
    },
    {
      "id": 23,
      "phase": "Payment Service",
      "title": "Payment Service - Validator",
      "description": [
        "I want you to create a validator named validator.go",
        "Make validation such as: amount > 0 or from_account and to_account in UUID format? Currency valid? from_account == to_account (it is forbidden)"
      ],
      "priority": "high",
      "status": "completed",
      "output": "payment-service/validator.go",
      "done_when": [
        "Simple validation added"
      ]
    },
    {
      "id": 24,
      "phase": "Payment Service",
      "title": "Payment Service - SPIFFE Integration",
      "description": [
        "I want you to implement SPIFFE Integration, just like in api-gateway.",
        "Make sure that you have valid env variable just like in api-gateway/spiffe.go",
        "In api-gateway, you are going to see PaymentServiceCredentials, make sure that you are integrated to this function."
      ],
      "priority": "high",
      "status": "completed",
      "output": "payment-service/spiffe.go",
      "done_when": [
        "payment-service/spiffe.go is created",
        "You have valid SPIFFE integration just like in api-gateway/spiffe.go"
      ]
    },
    {
      "id": 25,
      "phase": "Payment Service",
      "title": "Payment Service - Kafka",
      "description": [
        "topic: payment.initiated",
        "payload: payment_id, from_account, to_account, amount, currency, timestamp"
      ],
      "priority": "high",
      "status": "completed",
      "output": "payment-service/kafka.go",
      "done_when": [
        "Provide producer for notification service."
      ]
    },
    {
      "id": 26,
      "phase": "Payment Service",
      "title": "Payment Service - State",
      "description": [
        "PENDING -> COMPLETED (when account-service deducts balance)",
        "PENDING -> FAILED (insufficient balance or operation error)"
      ],
      "priority": "high",
      "status": "completed",
      "output": "payment-service/kafka.go",
      "done_when": [
        "Provide producer for notification service."
      ]
    },
    {
      "id": 27,
      "phase": "Deploy to Kubernetes",
      "title": "Create Deployment, Service, Serviceaccount, Configmap, Memory-related YAMLs for payment-service",
      "description": [
        "Create the YAML files mentioned in the title for payment-service inside the /k8s/payment/ folder. Also perform the necessary setup for SPIFFE/SPIRE there for payment-service. Explicitly state in the YAML which socket the certificate will be connected from, etc.",
        "You can use k8s/api-gateway as an example folder to accomplish this task."
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        16
      ],
      "output": "payment-service-deployment.yaml, payment-service-service.yaml, payment-service-serviceaccount.yaml, payment-service-configmap.yaml, payment-service-memory.yaml",
      "done_when": [
        "Deployment, Service, Serviceaccount, Configmap, Memory-related Yamls created for payment-service."
      ]
    },
    {
      "id": 28,
      "phase": "Deploy to Kubernetes",
      "title": "UPDATE REGISTER",
      "description": "Copy hack/5-register-spire.sh and create a new file hack/5-1-payment-register-spire.sh and create a register for payment-service according to .ctx folder. Apply it.",
      "priority": "high",
      "status": "completed",
      "output": "hack/5-1-payment-register-spire.sh",
      "done_when": [
        "Valid register is created for payment service",
        "Check if register is really created"
      ]
    },
    {
      "id": 29,
      "phase": "Deploy to Kubernetes",
      "title": "Apply Yamls for payment service",
      "description": "Apply the YAMLs found for payment service inside the /k8s/payment-service folder and ensure it works. Enter inside and ensure it receives SPIFFE certificate. System must work.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        28
      ],
      "output": "",
      "done_when": [
        "payment-service should reach to PostgreSQL in Kubernetes",
        "payment-service service received SPIFFE certificate inside Kubernetes.",
        "payment-service returned response to /health endpoint."
      ]
    },
    {
      "id": 30,
      "phase": "Deploy to Kubernetes",
      "title": "Check if api-gateway SPIFFE ---> payment-service SPIFFE integrated",
      "description": [
        "{'time':'2026-02-16T09:34:06.847525628Z','level':'WARN','msg':'Failed to connect to Payment Service (continuing without it)'','error':'failed to dial payment service: context deadline exceeded'}",
        "This error showing us api-gateway still cant see payment-service, check this out.",
      ],
      "priority": "high",
      "status": "completed",
      "output": "",
      "done_when": [
        "Api-gateway initialize payment-service spiffe certificate correctly."
      ]
    },
    {
      "id": 31,
      "phase": "Deploy to Kubernetes",
      "title": "Create a script for helm/bitnami-kafka",
      "description": [
        "Create a file hack/helm-kafka.sh, add these code (this is an example, if you get any error, you can change.)",
        "helm repo add bitnami https://charts.bitnami.com/bitnami",
        "helm repo update",
        "helm install secure-pay-kafka bitnami kafka set listeners.client.protocol=PLAINTEXT set listeners.controller.protocol=PLAINTEXT set listeners.interbroker.protocol=PLAINTEXT",
        "Check if it runs --> kubectl get pods",
        "kafka access (for an example) --> my-kafka.default.svc.cluster.local:9092",
        "Provide this into payment-service and rebuild with new version which is 0.0.2",
        "Make sure payment-service is running clearly."
      ],
      "status": "completed",
      "output": "hack/helm-bitnami-kafka.sh",
      "done_when": [
        "Helm Kafka added",
        "Kafka runs healthy",
        "New address implemented to payment-service",
        "Make sure payment-service is running after this implementation."
      ]
    },
    {
      "id": 32,
      "phase": "Enrichment",
      "title": "Enrichment Payment Service",
      "description": [
        "Remove hard-coded values and move them to a new file",
        "A function should be responsible for only one thing, nothing more.",
        "Structs should be in their own files."
      ],
      "status": "completed",
      "output": "",
      "done_when": [
        "wsl -d Ubuntu bash -c 'cd /home/doguhan/securepay/securepay; mkdir -p /tmp/docker-local; echo '{}' > /tmp/docker-local/config.json; export DOCKER_CONFIG=/tmp/docker-local; docker build -t payment-service:v0.0.2 -f payment-service/payment-service.dockerfile . && minikube image load payment-service:v0.0.2'"
      ]
    },
    {
      "id": 33,
      "phase": "Account Service",
      "title": "Account Service Initialize",
      "description": [
        "Initialize account service with packages for gRPC, kafka",
        "Create a main file that runs gRPC server and the port is 8082.",
        "Make sure that you have valid setup for connection to PostgreSQL",
        "You can use payment-service as an example.",
        "ID 32, was an enrichment task, no need for that. Instead, implement enrichment methods as default."
      ],
      "status": "completed",
      "output": "",
      "done_when": []
    },
    {
      "id": 33.5,
      "phase": "Deploy to Kubernetes",
      "title": "Create Deployment, Service, Serviceaccount, Configmap, Memory-related YAMLs for account-service",
      "description": [
        "IMPORTANT NOTE: You can use k8s/paymet-service as an instance. Make sure that you are integrated SPIFFE and PostgreSQL database url is valid.",
        "Create the YAML files mentioned in the title for account-service inside the /k8s/account/ folder. Also perform the necessary setup for SPIFFE/SPIRE there for account-service. Explicitly state in the YAML which socket the certificate will be connected from, etc.",
        "You can use k8s/api-gateway as an example folder to accomplish this task."
      ],
      "priority": "high",
      "status": "completed",
      "output": "account-service-deployment.yaml, account-service-service.yaml, account-service-serviceaccount.yaml, account-service-configmap.yaml, account-service-memory.yaml",
      "done_when": [
        "Deployment, Service, Serviceaccount, Configmap, Memory-related Yamls created for account-service."
      ]
    },
    {
      "id": 34,
      "phase": "Deploy to Kubernetes",
      "title": "Apply Yamls for account service",
      "description": "Apply the YAMLs found for account service inside the /k8s/account-service folder and ensure it works. Enter inside and ensure it receives SPIFFE certificate. System must work.",
      "priority": "high",
      "status": "completed",
      "depends_on": [
        33.5
      ],
      "output": "",
      "done_when": [
        "account-service should reach to PostgreSQL in Kubernetes",
        "account-service service received SPIFFE certificate inside Kubernetes.",
        "account-service returned response to /health endpoint."
      ]
    },
    {
      "id": 34.5,
      "phase": "Infrastructure - Prometheus And Grafana",
      "title": "Deploy Redis via Helm",
      "description": [
        "Add Prometheus and Grafana to K8s using Helm",
        "Make sure that api-gateway has a connection to the instance",
        "Provide a JSON for monitoring latency, traffic, errors, saturation."
      ],
      "priority": "high",
      "status": "completed",
      "output": "",
      "done_when": [
        "Prometheus and Grafana are installed with the help of Helm to k8s",
        "Prometheus and Grafana is ready to use",
        "api-gateway has a connection to this instance.",
        "User can monitor api-gateway by certain parameters"
      ]
    },
    {
      "id": 35,
      "phase": "Infrastructure - Redis",
      "title": "Deploy Redis via Helm",
      "description": [
        "USE YAMLS NOT BASH",
        "Install Redis using Helm chart in Kubernetes cluster.",
        "helm repo add bitnami https://charts.bitnami.com/bitnami",
        "helm repo update",
        "helm install secure-pay-redis bitnami/redis --set auth.enabled=true --set auth.password=redispass --set master.persistence.enabled=false",
        "Service name will be: secure-pay-redis-master.default.svc.cluster.local:6379",
        "Test connection: kubectl run redis-test --rm -i --image=redis:alpine -- redis-cli -h secure-pay-redis-master -a redispass ping",
        "Expected output: PONG"
      ],
      "priority": "high",
      "status": "completed",
      "depends_on": [
        34
      ],
      "output": "hack/helm-redis.sh",
      "done_when": [
        "Redis installed via Helm",
        "Redis service accessible from within cluster",
        "Connection test returns PONG"
      ]
    },
    {
      "id": 36,
      "phase": "Payment Service - Redis Integration",
      "title": "Implement Idempotency Check with Redis",
      "description": [
        "Create payment-service/internal/cache/redis.go file",
        "Implement idempotency check logic in handler.go:",
        "- Before saving to DB, check if idempotency:{key} exists in Redis",
        "- If exists: return saved response (fetch from Redis), do not repeat operation",
        "- If not exists: proceed with payment flow",
        "After successful Kafka publish, save idempotency record to Redis with TTL 86400 seconds (24 hours)",
        "Redis key format: idempotency:{idempotency_key}",
        "Value: JSON serialized response (payment_id, status, message)",
        "Add REDIS_ADDR to payment-service ConfigMap: secure-pay-redis-master.default.svc.cluster.local:6379",
        "Add REDIS_PASSWORD to payment-service ConfigMap or Secret",
        "Rebuild payment-service image as v0.0.3",
        "Update k8s/payment-service/payment-service-deployment.yaml with new version",
        "Test with duplicate idempotency_key to verify deduplication works"
      ],
      "priority": "high",
      "status": "completed",
      "depends_on": [
        35
      ],
      "output": "payment-service/internal/cache/redis.go",
      "done_when": [
        "redis.go file created with Get/Set methods",
        "Idempotency check integrated in InitiatePayment handler",
        "Duplicate requests return cached response without re-processing",
        "payment-service connects to Redis successfully",
        "End-to-end test with same idempotency_key returns identical response"
      ]
    },
    {
      "id": 37,
      "phase": "Account Service - Redis Integration",
      "title": "Implement Balance Cache with Redis",
      "description": [
        "Create account-service/internal/cache/cache.go file",
        "Implement read-aside cache pattern in handler.go CheckBalance:",
        "- Check Redis for balance:{account_id}",
        "- If exists (cache hit): return from Redis, TTL 60 seconds",
        "- If not exists (cache miss): fetch from PostgreSQL, write to Redis with TTL 60s, return",
        "Implement cache invalidation in kafka consumer:",
        "- After successful balance update transaction, delete balance:{from_account} and balance:{to_account} keys",
        "- This ensures next CheckBalance fetches fresh data from DB",
        "Redis key format: balance:{account_id}",
        "Value: JSON serialized {balance: float64, currency: string}",
        "Add REDIS_ADDR to account-service ConfigMap",
        "Add REDIS_PASSWORD to account-service ConfigMap or Secret",
        "Rebuild account-service image as v0.0.2",
        "Update k8s/account-service/account-service-deployment.yaml with new version",
        "Test: call CheckBalance twice, verify second call is faster (cache hit)"
      ],
      "priority": "high",
      "status": "completed",
      "depends_on": [
        35
      ],
      "output": "account-service/internal/cache/cache.go",
      "done_when": [
        "cache.go file created with Get/Set/Delete methods",
        "CheckBalance uses read-aside cache pattern",
        "Kafka consumer invalidates cache after balance update",
        "Cache TTL is 60 seconds as per conventions",
        "account-service connects to Redis successfully",
        "End-to-end test shows cache hit behavior"
      ]
    },
    {
      "id": 38,
      "phase": "Observability - Jaeger",
      "title": "Deploy Jaeger via Helm",
      "description": [
        "Install Jaeger using Helm chart for distributed tracing.",
        "helm repo add jaegertracing https://jaegertracing.github.io/helm-charts",
        "helm repo update",
        "helm install secure-pay-jaeger jaegertracing/jaeger --set provisionDataStore.cassandra=false --set allInOne.enabled=true --set storage.type=memory",
        "Jaeger UI will be accessible at: secure-pay-jaeger-query.default.svc.cluster.local:16686",
        "OTLP endpoint: secure-pay-jaeger-collector.default.svc.cluster.local:4317",
        "Expose Jaeger UI via port-forward for local access: kubectl port-forward svc/secure-pay-jaeger-query 16686:16686",
        "Test: Open http://localhost:16686 in browser, verify Jaeger UI loads"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        34
      ],
      "output": "hack/helm-jaeger.sh",
      "done_when": [
        "Jaeger installed via Helm",
        "Jaeger UI accessible via port-forward",
        "OTLP collector endpoint reachable from within cluster"
      ]
    },
    {
      "id": 39,
      "phase": "API Gateway - OpenTelemetry",
      "title": "Implement OpenTelemetry Tracing in API Gateway",
      "description": [
        "Create api-gateway/telemetry.go file",
        "Initialize OpenTelemetry tracer with OTLP exporter pointing to Jaeger collector",
        "OTLP endpoint: secure-pay-jaeger-collector.default.svc.cluster.local:4317",
        "Implement W3C TraceContext propagation (this is the standard)",
        "Instrument router.go: create spans for each HTTP request",
        "Span naming convention: 'service.operation' (e.g., 'api-gateway.initiate-payment')",
        "Propagate trace context to downstream gRPC calls (Payment Service, Account Service)",
        "Add trace_id to all structured logs using slog.Info/Error",
        "Add OTEL_EXPORTER_OTLP_ENDPOINT to api-gateway ConfigMap",
        "Rebuild api-gateway image as v1.0.2",
        "Update k8s/api-gateway/apigateway-deployment.yaml with new version",
        "Test: Make API call, verify trace appears in Jaeger UI with all spans"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        38
      ],
      "output": "api-gateway/telemetry.go",
      "done_when": [
        "telemetry.go file created with tracer initialization",
        "HTTP requests create spans with proper naming",
        "Trace context propagated to gRPC clients",
        "All logs include trace_id field",
        "End-to-end trace visible in Jaeger UI"
      ]
    },
    {
      "id": 40,
      "phase": "Payment Service - OpenTelemetry",
      "title": "Implement OpenTelemetry Tracing in Payment Service",
      "description": [
        "Create payment-service/internal/telemetry/telemetry.go file",
        "Initialize OpenTelemetry tracer with OTLP exporter pointing to Jaeger",
        "Instrument handler.go: create spans for InitiatePayment and GetPayment operations",
        "Instrument repository.go: create spans for DB operations (SavePayment, GetPayment)",
        "Instrument kafka.go: create spans for Kafka produce operations",
        "Span naming: 'payment-service.initiate-payment', 'payment-service.db.save-payment', etc.",
        "Extract trace context from incoming gRPC requests (from API Gateway)",
        "Add trace_id to all slog.Info/Error calls",
        "Add OTEL_EXPORTER_OTLP_ENDPOINT to payment-service ConfigMap",
        "Rebuild payment-service image as v0.0.4",
        "Update k8s/payment-service/payment-service-deployment.yaml",
        "Test: Initiate payment via API Gateway, verify full trace in Jaeger"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        38,
        39
      ],
      "output": "payment-service/internal/telemetry/telemetry.go",
      "done_when": [
        "telemetry.go file created",
        "All major operations instrumented with spans",
        "Trace context extracted from gRPC metadata",
        "Logs include trace_id",
        "Distributed trace shows API Gateway -> Payment Service flow"
      ]
    },
    {
      "id": 41,
      "phase": "Account Service - OpenTelemetry",
      "title": "Implement OpenTelemetry Tracing in Account Service",
      "description": [
        "Create account-service/internal/telemetry/telemetry.go file",
        "Initialize OpenTelemetry tracer with OTLP exporter",
        "Instrument handler.go: create spans for CheckBalance",
        "Instrument repository.go: create spans for DB operations (GetAccount, ProcessPayment)",
        "Instrument cache.go: create spans for Redis operations (cache hit/miss)",
        "Instrument kafka consumer: create spans for event processing",
        "Span naming: 'account-service.check-balance', 'account-service.process-payment', etc.",
        "Extract trace context from gRPC requests and Kafka messages",
        "Add trace_id to all logs",
        "Add OTEL_EXPORTER_OTLP_ENDPOINT to account-service ConfigMap",
        "Rebuild account-service image as v0.0.3",
        "Test: Full payment flow, verify trace includes Account Service spans"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        38,
        40
      ],
      "output": "account-service/internal/telemetry/telemetry.go",
      "done_when": [
        "telemetry.go file created",
        "CheckBalance and ProcessPayment instrumented",
        "Kafka consumer propagates trace context",
        "Complete distributed trace visible: API Gateway -> Payment -> Kafka -> Account"
      ]
    },
    {
      "id": 42,
      "phase": "Notification Service - OpenTelemetry",
      "title": "Implement OpenTelemetry Tracing in Notification Service (Java)",
      "description": [
        "Create notification-service/src/main/java/com/securepay/notification/telemetry/TelemetryConfig.java",
        "Add OpenTelemetry dependencies to pom.xml:",
        "- io.opentelemetry:opentelemetry-api",
        "- io.opentelemetry:opentelemetry-sdk",
        "- io.opentelemetry:opentelemetry-exporter-otlp",
        "- io.opentelemetry.instrumentation:opentelemetry-spring-boot-starter",
        "Configure OTLP exporter in application.yml or TelemetryConfig.java",
        "Instrument PaymentEventConsumer: create span when Kafka message received",
        "Extract trace context from Kafka message headers (W3C TraceContext)",
        "Span naming: 'notification-service.process-payment-event'",
        "Add trace_id to logging MDC (Mapped Diagnostic Context) for SLF4J",
        "Update k8s/notification-service/notification-service-configmap.yaml with OTEL endpoint",
        "Rebuild notification-service image as v0.0.5",
        "Test: Full flow, verify Notification Service appears in Jaeger trace"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        38,
        41
      ],
      "output": "notification-service/src/main/java/com/securepay/notification/telemetry/TelemetryConfig.java",
      "done_when": [
        "OpenTelemetry dependencies added to pom.xml",
        "TelemetryConfig.java created",
        "Kafka consumer extracts and propagates trace context",
        "Notification service appears in distributed trace"
      ]
    },
    {
      "id": 43,
      "phase": "End-to-End Testing",
      "title": "Create End-to-End Test Script",
      "description": [
        "Create scripts/e2e-test.sh bash script",
        "Test flow: Initiate Payment -> Check Jaeger Trace -> Verify Balance Updated",
        "Steps:",
        "1. Generate JWT token (use existing scripts/gen_token.py or api-gateway/cmd/token/main.go)",
        "2. Call CheckBalance for from_account (11111111-1111-1111-1111-111111111111), store initial balance",
        "3. Call InitiatePayment with unique payment_id and idempotency_key",
        "4. Assert response status is PENDING",
        "5. Sleep 2 seconds (wait for Kafka consumer to process)",
        "6. Call CheckBalance again, verify balance decreased by payment amount",
        "7. Call CheckBalance for to_account (22222222-2222-2222-2222-222222222222), verify balance increased",
        "8. Call InitiatePayment with SAME idempotency_key, verify returns cached response (idempotency works)",
        "9. Query Jaeger API to verify trace exists with all expected spans",
        "Script should output: PASS or FAIL with details",
        "Add script to README.md under 'Testing' section"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        36,
        37,
        42
      ],
      "output": "scripts/e2e-test.sh",
      "done_when": [
        "e2e-test.sh script created",
        "Script tests full payment flow",
        "Idempotency verified",
        "Balance changes verified",
        "Jaeger trace verification included",
        "Script returns exit code 0 on success"
      ]
    },
    {
      "id": 44,
      "phase": "Terraform - Structure",
      "title": "Initialize Terraform Project Structure",
      "description": [
        "Create terraform/ directory at project root",
        "Create subdirectories: terraform/modules/, terraform/environments/",
        "Create terraform/modules/eks/ for EKS cluster module",
        "Create terraform/modules/vpc/ for VPC networking module",
        "Create terraform/modules/rds/ for PostgreSQL RDS module",
        "Create terraform/modules/msk/ for Kafka MSK module",
        "Create terraform/modules/elasticache/ for Redis ElastiCache module",
        "Create terraform/environments/dev/ for development environment config",
        "Create terraform/README.md explaining structure and purpose",
        "NOTE: These are infrastructure-as-code definitions, NOT meant to be applied (free tier exhausted)",
        "Purpose: Demonstrate production-ready IaC skills for CV"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        43
      ],
      "output": "terraform/ directory structure",
      "done_when": [
        "Directory structure created",
        "README.md explains purpose and structure",
        "Clear separation: modules vs environments"
      ]
    },
    {
      "id": 45,
      "phase": "Terraform - VPC Module",
      "title": "Create VPC Module for AWS Networking",
      "description": [
        "Create terraform/modules/vpc/main.tf",
        "Define VPC with CIDR 10.0.0.0/16",
        "Create 3 public subnets (10.0.1.0/24, 10.0.2.0/24, 10.0.3.0/24) across 3 AZs",
        "Create 3 private subnets (10.0.11.0/24, 10.0.12.0/24, 10.0.13.0/24) across 3 AZs",
        "Create Internet Gateway for public subnets",
        "Create NAT Gateway in one public subnet (cost optimization - single NAT)",
        "Create route tables: public route to IGW, private route to NAT",
        "Tag subnets for EKS: kubernetes.io/cluster/securepay = shared, kubernetes.io/role/elb = 1 (public), kubernetes.io/role/internal-elb = 1 (private)",
        "Create terraform/modules/vpc/variables.tf for customization",
        "Create terraform/modules/vpc/outputs.tf (vpc_id, public_subnet_ids, private_subnet_ids)",
        "Add detailed comments explaining each resource"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        44
      ],
      "output": "terraform/modules/vpc/",
      "done_when": [
        "VPC module with public/private subnets",
        "NAT Gateway and Internet Gateway configured",
        "EKS-compatible subnet tags",
        "Well-documented with comments"
      ]
    },
    {
      "id": 46,
      "phase": "Terraform - EKS Module",
      "title": "Create EKS Cluster Module",
      "description": [
        "Create terraform/modules/eks/main.tf",
        "Define EKS cluster resource with Kubernetes version 1.28",
        "Configure cluster in private subnets (control plane)",
        "Create IAM role for EKS cluster with necessary policies",
        "Define managed node group: 2-4 nodes, t3.medium instance type",
        "Node group in private subnets with autoscaling",
        "Enable EKS add-ons: vpc-cni, coredns, kube-proxy",
        "Configure OIDC provider for IAM roles for service accounts (IRSA)",
        "Create terraform/modules/eks/variables.tf (cluster_name, node_instance_type, min/max nodes)",
        "Create terraform/modules/eks/outputs.tf (cluster_endpoint, cluster_certificate_authority_data, cluster_name)",
        "Add security group rules for node-to-node communication",
        "Document SPIRE deployment compatibility in comments"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        45
      ],
      "output": "terraform/modules/eks/",
      "done_when": [
        "EKS cluster module with managed node group",
        "IAM roles and OIDC provider configured",
        "Security groups for cluster communication",
        "Documentation on SPIRE/Kubernetes integration"
      ]
    },
    {
      "id": 47,
      "phase": "Terraform - RDS Module",
      "title": "Create RDS PostgreSQL Module",
      "description": [
        "Create terraform/modules/rds/main.tf",
        "Define RDS PostgreSQL 16 instance",
        "Instance class: db.t3.micro (smallest for cost efficiency in example)",
        "Multi-AZ: false (cost optimization for dev)",
        "Storage: 20GB gp3, encrypted",
        "Create DB subnet group using private subnets",
        "Create security group allowing PostgreSQL (5432) from EKS node security group only",
        "Database name: securepay, master username: securepay_admin",
        "Enable automated backups (retention 7 days)",
        "Create terraform/modules/rds/variables.tf (db_name, master_username, instance_class, allocated_storage)",
        "Create terraform/modules/rds/outputs.tf (endpoint, port, database_name)",
        "Use AWS Secrets Manager for password (reference in comments, not actual secret creation)",
        "Add comment explaining schema separation (payments, accounts) done via SQL init scripts"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        46
      ],
      "output": "terraform/modules/rds/",
      "done_when": [
        "RDS PostgreSQL module",
        "Security group restricts access to EKS nodes only",
        "Encryption and backups enabled",
        "Documentation on schema initialization"
      ]
    },
    {
      "id": 48,
      "phase": "Terraform - MSK Module",
      "title": "Create MSK (Managed Kafka) Module",
      "description": [
        "Create terraform/modules/msk/main.tf",
        "Define MSK cluster with Kafka version 3.5.1",
        "Cluster type: Provisioned (t3.small brokers for cost efficiency)",
        "Number of brokers: 3 (one per AZ in private subnets)",
        "Storage: 100GB EBS per broker",
        "Create security group allowing Kafka (9092) from EKS node security group",
        "Enable encryption in transit: TLS (though SecurePay doesn't use it, production best practice)",
        "Enable encryption at rest",
        "Create client authentication: IAM (for access control)",
        "Create terraform/modules/msk/variables.tf (cluster_name, broker_instance_type, broker_storage)",
        "Create terraform/modules/msk/outputs.tf (bootstrap_brokers, zookeeper_connect_string)",
        "Add comment: Topic 'payment.initiated' created via Kafka admin tools, not Terraform",
        "Document consumer groups in comments"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        46
      ],
      "output": "terraform/modules/msk/",
      "done_when": [
        "MSK cluster module with 3 brokers",
        "Security group and encryption configured",
        "IAM authentication enabled",
        "Documentation on topic management"
      ]
    },
    {
      "id": 49,
      "phase": "Terraform - ElastiCache Module",
      "title": "Create ElastiCache Redis Module",
      "description": [
        "Create terraform/modules/elasticache/main.tf",
        "Define ElastiCache Redis cluster",
        "Engine version: 7.0",
        "Node type: cache.t3.micro",
        "Number of cache nodes: 1 (non-clustered for simplicity)",
        "Create subnet group using private subnets",
        "Create security group allowing Redis (6379) from EKS node security group only",
        "Enable encryption at rest and in transit (AUTH token)",
        "Automatic failover: disabled (single node)",
        "Create terraform/modules/elasticache/variables.tf (cluster_id, node_type, num_cache_nodes)",
        "Create terraform/modules/elasticache/outputs.tf (primary_endpoint_address, port, auth_token)",
        "Add comment: Used for idempotency (payment-service) and balance cache (account-service)",
        "Document TTL strategies in comments"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        46
      ],
      "output": "terraform/modules/elasticache/",
      "done_when": [
        "ElastiCache Redis module",
        "Security group restricts access to EKS",
        "Encryption and AUTH enabled",
        "Documentation on use cases"
      ]
    },
    {
      "id": 50,
      "phase": "Terraform - Environment",
      "title": "Create Dev Environment Configuration",
      "description": [
        "Create terraform/environments/dev/main.tf",
        "Compose all modules: VPC, EKS, RDS, MSK, ElastiCache",
        "Pass VPC outputs to EKS, RDS, MSK, ElastiCache modules",
        "Pass EKS node security group to RDS, MSK, ElastiCache security group rules",
        "Create terraform/environments/dev/variables.tf (region, project_name, environment)",
        "Create terraform/environments/dev/terraform.tfvars.example with sample values",
        "Create terraform/environments/dev/backend.tf.example (S3 backend config - NOT applied)",
        "Create terraform/environments/dev/provider.tf (AWS provider configuration)",
        "Add comprehensive comments explaining module composition",
        "Add README.md in terraform/environments/dev/ with:",
        "- Purpose of this environment",
        "- Module dependencies diagram (text-based or link to architecture.md)",
        "- Cost estimation (rough estimate for all resources)",
        "- Note: 'This is demonstration IaC, not applied due to free tier limits'"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        45,
        46,
        47,
        48,
        49
      ],
      "output": "terraform/environments/dev/",
      "done_when": [
        "All modules composed in dev environment",
        "Variables and example tfvars file",
        "Backend configuration example",
        "README with cost estimation and purpose"
      ]
    },
    {
      "id": 51,
      "phase": "Terraform - Documentation",
      "title": "Create Comprehensive Terraform Documentation",
      "description": [
        "Update terraform/README.md with:",
        "- Project overview: 'Production-ready IaC for SecurePay deployment on AWS EKS'",
        "- Module descriptions (VPC, EKS, RDS, MSK, ElastiCache)",
        "- Architecture diagram (text-based ASCII or reference to architecture.md)",
        "- Prerequisites: Terraform version, AWS CLI, kubectl",
        "- How to use: terraform init, plan, apply commands (with warning: DO NOT APPLY)",
        "- Estimated monthly cost breakdown for all resources",
        "- Migration path from Minikube to EKS (helm chart adaptations needed)",
        "- Security considerations: encryption, IAM policies, security groups",
        "- Comparison table: Local (Minikube, PostgreSQL in K8s, Kafka in K8s) vs Production (EKS, RDS, MSK, ElastiCache)",
        "- Add to .ctx/decisions.md:",
        "Decision: Why EKS over ECS (Kubernetes-native project, SPIRE compatibility)",
        "Decision: Why managed services (RDS, MSK, ElastiCache) over self-hosted (operational simplicity)",
        "Update main project README.md:",
        "- Add 'Production Deployment' section referencing terraform/ directory",
        "- Link to terraform/README.md"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        50
      ],
      "output": "terraform/README.md, updated .ctx/decisions.md, updated project README.md",
      "done_when": [
        "Comprehensive Terraform documentation",
        "Architecture diagram",
        "Cost estimation",
        "Architectural decision records updated",
        "Main README references Terraform deployment"
      ]
    },
    {
      "id": 52,
      "phase": "CI/CD - Lint",
      "title": "Implement Linting in GitHub Actions",
      "description": [
        "Create .github/workflows/lint.yml",
        "Job 1: golangci-lint for Go services (api-gateway, payment-service, account-service)",
        "- Use golangci/golangci-lint-action@v3",
        "- Run on: pull_request, push to main",
        "- Lint each service directory separately",
        "Create .golangci.yml in project root:",
        "- Enable linters: gofmt, goimports, govet, errcheck, staticcheck, unused, gosimple",
        "- Set timeout: 5m",
        "Job 2: checkstyle for Java Notification Service",
        "- Use maven checkstyle plugin",
        "- Run: mvn checkstyle:check in notification-service/",
        "Create notification-service/checkstyle.xml with Google Java Style checks",
        "Both jobs must pass for PR to be mergeable",
        "Add badge to README.md: [![Lint](badge-url)](workflow-url)"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        43
      ],
      "output": ".github/workflows/lint.yml, .golangci.yml, notification-service/checkstyle.xml",
      "done_when": [
        "lint.yml workflow created",
        "golangci-lint runs on all Go services",
        "checkstyle runs on Java service",
        "Workflow badge added to README"
      ]
    },
    {
      "id": 53,
      "phase": "CI/CD - Test",
      "title": "Implement Unit Testing in GitHub Actions",
      "description": [
        "Create .github/workflows/test.yml",
        "Job: Go unit tests for all Go services",
        "- Run: go test -v -race -coverprofile=coverage.out ./...",
        "- Run in each service directory (api-gateway, payment-service, account-service)",
        "- Upload coverage report using codecov/codecov-action or coverallsapp/github-action",
        "Coverage threshold: Warn if below 50%, fail if below 30% (adjustable)",
        "Write unit tests (minimum coverage for critical paths):",
        "- payment-service/internal/validator/validator_test.go (test ValidateInitiatePayment)",
        "- payment-service/internal/repository/repository_test.go (use testcontainers for PostgreSQL or mock)",
        "- account-service/internal/repository/repository_test.go",
        "- api-gateway/middleware/jwt_test.go (test token validation)",
        "Job should run on: pull_request, push to main",
        "Add coverage badge to README.md"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        52
      ],
      "output": ".github/workflows/test.yml, *_test.go files",
      "done_when": [
        "test.yml workflow created",
        "Unit tests written for critical paths (validator, repository, middleware)",
        "Coverage report generated and uploaded",
        "Coverage badge added to README"
      ]
    },
    {
      "id": 54,
      "phase": "CI/CD - Security",
      "title": "Implement Security Scanning in GitHub Actions",
      "description": [
        "Create .github/workflows/security.yml",
        "Job 1: Trivy container image scan",
        "- Use aquasecurity/trivy-action@master",
        "- Scan all Docker images (api-gateway, payment-service, account-service, notification-service)",
        "- Scan for: OS vulnerabilities, application dependencies vulnerabilities",
        "- Severity: Fail on HIGH and CRITICAL, warn on MEDIUM",
        "- Upload results to GitHub Security tab (SARIF format)",
        "Job 2: gosec for Go static security analysis",
        "- Use securego/gosec",
        "- Run on all Go services",
        "- Check for: hardcoded credentials, weak crypto, SQL injection patterns, etc.",
        "Job 3: OWASP Dependency-Check for Java (optional, can be slow)",
        "- Run: mvn org.owasp:dependency-check-maven:check",
        "- Check notification-service dependencies",
        "Run on: pull_request, push to main, scheduled (weekly)",
        "Add security badge to README.md"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        53
      ],
      "output": ".github/workflows/security.yml",
      "done_when": [
        "security.yml workflow created",
        "Trivy scans all Docker images",
        "gosec scans Go code",
        "Security findings uploaded to GitHub Security tab",
        "Security badge added to README"
      ]
    },
    {
      "id": 55,
      "phase": "CI/CD - Build",
      "title": "Implement Docker Multi-Platform Build in GitHub Actions",
      "description": [
        "Create .github/workflows/build.yml",
        "Job: Build and push Docker images",
        "- Trigger on: push to main, tags (v*)",
        "- Use docker/build-push-action@v5",
        "- Setup Docker Buildx for multi-platform builds",
        "- Build for: linux/amd64, linux/arm64 (optional, adds build time)",
        "- Tag strategy: latest (on main), semantic version (on tags v*)",
        "- Push to Docker Hub (requires DOCKERHUB_USERNAME and DOCKERHUB_TOKEN secrets)",
        "- Build all services: api-gateway, payment-service, account-service, notification-service",
        "- Use cache to speed up builds (type=gha)",
        "Create docker/build-context.sh helper script if needed",
        "Add note in README: Images available at dockerhub.com/u/securepay (or your username)",
        "For CV purposes, can also push to GitHub Container Registry (ghcr.io)"
      ],
      "priority": "medium",
      "status": "pending",
      "depends_on": [
        54
      ],
      "output": ".github/workflows/build.yml",
      "done_when": [
        "build.yml workflow created",
        "Multi-platform Docker builds",
        "Images pushed to registry on main/tags",
        "Cache strategy implemented for faster builds",
        "Registry information documented in README"
      ]
    },
    {
      "id": 56,
      "phase": "CI/CD - Helm Validation",
      "title": "Implement Helm Chart Validation",
      "description": [
        "Create .github/workflows/helm-validate.yml",
        "Job: Validate Helm charts and Kubernetes manifests",
        "- Use azure/setup-helm to install Helm CLI",
        "- Run: helm lint on any Helm charts (if you create charts later)",
        "- Run: kubectl --dry-run=client -f k8s/ to validate YAML syntax",
        "- Use kubeconform or kubeval to validate Kubernetes schema compliance",
        "- Check for: invalid API versions, missing required fields, deprecated resources",
        "Run on: pull_request, push to main",
        "Optional: Add kustomize validation if you use kustomize overlays",
        "Add validation badge to README"
      ],
      "priority": "low",
      "status": "pending",
      "depends_on": [
        55
      ],
      "output": ".github/workflows/helm-validate.yml",
      "done_when": [
        "helm-validate.yml workflow created",
        "Helm lint and kubectl dry-run validations",
        "Schema validation with kubeconform",
        "Badge added to README"
      ]
    },
    {
      "id": 57,
      "phase": "Documentation - Final",
      "title": "Complete Project Documentation",
      "description": [
        "Update main README.md with:",
        "- Project overview and architecture summary",
        "- Prerequisites (Go, Docker, Kubernetes, Helm, Terraform)",
        "- Local development setup (Minikube, PostgreSQL, Kafka, Redis, Jaeger)",
        "- Quick start guide (step-by-step from zero to running)",
        "- Testing section (unit tests, e2e tests, how to run)",
        "- CI/CD badges (lint, test, security, build)",
        "- Production deployment reference (terraform/ directory)",
        "- Project structure explanation",
        "- Technology stack with versions",
        "- License (MIT)",
        "Update .ctx/architecture.md:",
        "- Add Redis to services table",
        "- Add Jaeger to services table",
        "- Update payment flow with idempotency check step",
        "- Add distributed tracing flow",
        "Create CONTRIBUTING.md:",
        "- How to contribute (though personal project)",
        "- Code style guidelines",
        "- PR process",
        "Create CHANGELOG.md:",
        "- Version history",
        "- What changed in each version",
        "Ensure all .ctx files are up-to-date with final architecture"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        56
      ],
      "output": "Updated README.md, .ctx/architecture.md, CONTRIBUTING.md, CHANGELOG.md",
      "done_when": [
        "Comprehensive README with quick start guide",
        "All badges displayed",
        "Architecture documentation updated",
        "Contributing guidelines present",
        "Changelog tracks versions"
      ]
    },
    {
      "id": 58,
      "phase": "CV Preparation",
      "title": "Extract CV Bullet Points from SecurePay",
      "description": [
        "Based on completed project, write CV bullet points.",
        "Format: Action verb + Technical detail + Business outcome/Scale",
        "Example bullets:",
        "- 'Architected zero-trust fintech payment platform using SPIFFE/SPIRE for workload identity, achieving automated certificate rotation with <1hr TTL and eliminating static credentials across 4 microservices'",
        "- 'Implemented event-driven architecture with Kafka, enabling async communication between Payment and Account services with idempotency guarantees via Redis cache (24hr TTL)'",
        "- 'Deployed polyglot microservices (Go 3, Java 1) on Kubernetes using Helm, with distributed tracing via OpenTelemetry/Jaeger achieving end-to-end request visibility across gRPC and Kafka'",
        "- 'Designed production-ready AWS infrastructure-as-code with Terraform (EKS, RDS, MSK, ElastiCache), modularizing VPC, compute, and data tier for multi-environment deployments'",
        "- 'Established CI/CD pipeline with GitHub Actions (lint, test, security scan, multi-platform build), achieving <10min build times and automated vulnerability detection'",
        "Save these in a new file: cv-bullets.md",
        "Also create a 1-paragraph project summary for CV projects section",
        "Review and refine bullets for clarity and impact"
      ],
      "priority": "high",
      "status": "pending",
      "depends_on": [
        57
      ],
      "output": "cv-bullets.md",
      "done_when": [
        "5-7 polished CV bullet points",
        "Project summary paragraph",
        "Bullets emphasize scale, impact, and technical depth"
      ]
    }
  ]
}